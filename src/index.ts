// import { Probot } from "probot";
// import * as dotenv from "dotenv";
// import queryInkeepQA from "./inkeepClient.js";
// import { classifyIssueWithInkeep } from "./triageClassifier.js";

// dotenv.config();

// const probotApp = (app: Probot) => {
//   app.on("issues.opened", async context => {
//     const { title, body, number } = context.payload.issue;
//     const safeTitle = title ?? "";
//     const safeBody = body ?? "";
//     const fullQuestion = `${safeTitle}\n\n${safeBody}`;

//     console.log(`üìù Received issue #${number}: "${safeTitle}"`);

//     // Step 1: Use triage classifier to decide
//     const decision = await classifyIssueWithInkeep(safeTitle, safeBody);

//     if (decision === "defer") {
//       console.log(`‚è≠Ô∏è Skipping issue #${number} (deferred by classifier)`);
//       await context.octokit.issues.createComment(context.issue({
//         body: `ü§ñ This issue doesn't appear to be related to Inkeep, so I'm skipping it for now.`
//       }));
//       return;
//     }

//     // Step 2: Get answer from Inkeep
//     try {
//       const inkeepResponse = await queryInkeepQA(fullQuestion);
//       const rawText = inkeepResponse.text ??  "‚ö†Ô∏è No helpful answer found.";

//       await context.octokit.issues.createComment(context.issue({
//         body: `ü§ñ Here's a suggested answer from Inkeep:\n\n${rawText}\n\n---\n_This response was generated by an AI assistant._`
//       }));

//       console.log(`‚úÖ Responded to issue #${number}`);
//     } catch (err: any) {
//       console.error(`‚ùå Failed to query Inkeep or comment on issue #${number}:`, err?.message);
//     }
//   });
// };

// export default probotApp;

// import { Probot } from "probot";
// import * as dotenv from "dotenv";
// import queryInkeepQA from "./inkeepClient.js";

// dotenv.config();

// // Map Inkeep confidence labels to estimated % values
// function mapConfidenceToPercentage(level: string): number {
//   switch (level) {
//     case "very_confident": return 95;
//     case "confident": return 80;
//     case "unsure": return 55;
//     case "very_unsure": return 25;
//     case "none":
//     case "unknown":
//     default: return 0;
//   }
// }

// // Format the final response (or suppress it if below threshold or defer)
// function formatInkeepResponse(
//   rawText: string,
//   confidenceLabel: string,
//   minPercent: number = 54
// ): string | null {
//   const confidencePercent = mapConfidenceToPercentage(confidenceLabel);
//   const normalized = rawText.trim().toLowerCase();

//   const deferPhrases = [
//     "i'm sorry, but",
//     "i wasn't sure whether this issue relates to inkeep",
//     "this appears to be outside my area of expertise",
//     "i only have the ability to answer questions about inkeep",
//     "i couldn't find anything helpful"
//   ];

//   const isDeferral = deferPhrases.some(p => normalized.includes(p));
//   if (isDeferral || confidencePercent < minPercent) {
//     console.log(`üîá Skipping: confidence ${confidencePercent}%, deferral=${isDeferral}`);
//     return null;
//   }

//   const prefix = confidencePercent < 80
//     ? "üí° *AI-generated (low confidence)*:\n\n"
//     : "ü§ñ Here's a suggested answer from Inkeep:\n\n";

//   return `${prefix}${rawText}`;
// }

// // Probot entrypoint
// const probotApp = (app: Probot) => {
//   app.on("issues.opened", async context => {
//     const issue = context.payload.issue;
//     const question = `${issue.title}\n\n${issue.body}`;

//     try {
//       const inkeepResponse = await queryInkeepQA(question);

//       const rawText = inkeepResponse.text;
//       const confidence = inkeepResponse.aiAnnotations?.answerConfidence ?? "unknown";

//       const comment = formatInkeepResponse(rawText, confidence);

//       if (comment) {
//         await context.octokit.issues.createComment(context.issue({ body: comment }));
//         console.log(`‚úÖ Responded to issue #${issue.number}`);
//       } else {
//         console.log(`ü§î No confident AI response for issue #${issue.number}`);
//       }
      
//     } catch (err) {
//       console.error("‚ùå Failed to handle issue:", err);
//     }
//   });
// };

// export default probotApp;
// //OLD
// import { Probot } from "probot";
// import * as dotenv from "dotenv";
// import queryInkeepQA from "./inkeepClient.js";
// //import { classifyIssueWithInkeep } from "./triageClassifier.js";

// dotenv.config();

// // Probot app entrypoint
// const probotApp = (app: Probot) => {
//   app.on("issues.opened", async context => {
//     const { title, body, number } = context.payload.issue;
//     const safeTitle = title ?? "";
//     const safeBody = body ?? "";
//     const fullQuestion = `${safeTitle}\n\n${safeBody}`;

//     console.log(`üìù Issue #${number} received`);

//     // Classify if we should even try Inkeep
//     // const decision = await classifyIssueWithInkeep(safeTitle, safeBody);

//     // if (decision === "defer") {
//     //   console.log(`‚è≠Ô∏è Skipping issue #${number} (classified as defer)`);
//     //   await context.octokit.issues.createComment(context.issue({
//     //     body: `ü§ñ This issue doesn't appear to be related to Inkeep, so I'm skipping it for now.`
//     //   }));
//     //   return;
//     // }

//     try {
//       // Query Inkeep for an answer
//       const inkeepResponse = await queryInkeepQA(fullQuestion);
//       const rawText = inkeepResponse.text ?? "‚ö†Ô∏è No helpful answer found.";
//       const confidence = inkeepResponse.aiAnnotations?.answerConfidence ?? "unknown";
//       const explanation = inkeepResponse.aiAnnotations?.explanation ?? "";

//       const shouldRespond = ["very_confident", "somewhat_confident"].includes(confidence);

//       if (!shouldRespond) {
//         console.log(`üîá Skipping issue #${number}: answerConfidence='${confidence}'`);
//         return;
//       }

//       const disclaimer = confidence === "somewhat_confident"
//         ? `\n\nüü° _Confidence: ${confidence}. ${explanation}_`
//         : `\n\n‚úÖ _Confidence: ${confidence}_`;

//       await context.octokit.issues.createComment(context.issue({
//         body: `ü§ñ Here's a suggested answer from Inkeep:\n\n${rawText}${disclaimer}\n\n---\n_This response was generated by an AI assistant._`
//       }));

//       console.log(`‚úÖ Responded to issue #${number} with confidence '${confidence}'`);
//     } catch (err: any) {
//       console.error(`‚ùå Failed to handle issue #${number}:`, err?.message);
//     }
//   });
// };

// export default probotApp;
// import { Probot, Context } from "probot";
// import * as dotenv from "dotenv";
// import { createOpenAI } from "@ai-sdk/openai";
// import { generateText } from "ai";
// import {
//   ProvideAIAnnotationsToolSchema,
//   ProvideLinksToolSchema
// } from "./schemas.js";
// import type { Message } from "ai";

// dotenv.config();

// export default (app: Probot) => {
//   const inkeepModel = 'inkeep-qa-expert';
//   const openai = createOpenAI({
//     apiKey: process.env.INKEEP_API_KEY,
//     baseURL: 'https://api.inkeep.com/v1'
//   });

//   const systemPrompt = `
// You are a helpful AI assistant responding to GitHub issues. Your goal is to provide accurate, helpful answers based on available documentation and knowledge sources.

// - Be direct and concise in your responses
// - Focus on providing actionable solutions
// - If you're not confident about an answer, indicate your uncertainty
// - Use a natural, helpful tone without being overly formal
// - Avoid phrases like "According to the documentation" - just state facts directly
// `;

//   app.on(["issues.opened", "issues.reopened"], async (context: Context) => {
//     // Make number available in catch scope
//     let issueNumber: number | undefined = undefined;
//     try {
//       if (!('issue' in context.payload)) {
//         console.error("‚ùå Event payload does not contain an 'issue' property.");
//         return;
//       }
//       const { title, body, number } = context.payload.issue;
//       issueNumber = number;
//       const safeTitle = title ?? "";
//       const safeBody = body ?? "";
//       const fullQuestion = `${safeTitle}\n\n${safeBody}`;

//       console.log(`üìù Issue #${number} received: "${safeTitle}"`);

//         // Prepare messages with system prompt
//         const messages: Message[] = [
//           { id: "system-1", role: "system", content: systemPrompt },
//           { id: "user-1", role: "user", content: fullQuestion }
//         ];

//         // Call Inkeep model with AI tools
//         const { text, toolCalls } = await generateText({
//           model: openai(inkeepModel),
//           messages,
//           tools: {
//             provideAIAnnotations: { 
//               parameters: ProvideAIAnnotationsToolSchema 
//             },
//             provideLinks: { 
//               parameters: ProvideLinksToolSchema 
//             }
//           },
//           toolChoice: 'auto'
//         });

//         // Extract AI annotations (confidence level)
//         const aiAnnotations = toolCalls.find(tc => tc.toolName === 'provideAIAnnotations')
//           ?.args.aiAnnotations;
        
//         const confidence = aiAnnotations?.answerConfidence ?? 'unknown';
//         const explanation = (aiAnnotations as any)?.explanation ?? '';

//         console.log(`üéØ Issue #${number} confidence level: ${confidence}`);

//         // Only respond if confidence is high enough (matching Zendesk logic)
//         const shouldRespond = confidence === 'very_confident';
        
//         if (!shouldRespond) {
//           console.log(`üîá Skipping issue #${number}: confidence level '${confidence}' below threshold`);
          
//           // Optionally add a subtle note for somewhat_confident cases
//           if (confidence === 'somewhat_confident') {
//             console.log(`üí≠ Issue #${number} was somewhat confident but below response threshold`);
//           }
//           return;
//         }

//         // Build the response comment
//         let commentBody = `ü§ñ Here's a suggested solution:\n\n${text}`;
        
//         // Add confidence indicator
//         if (confidence === 'very_confident') {
//           commentBody += `\n\n‚úÖ _High confidence response_`;
//         }
        
//         // Add explanation if provided
//         if (explanation) {
//           commentBody += `\n\nüí° _${explanation}_`;
//         }
        
//         commentBody += `\n\n---\n_This response was generated by an AI assistant. Please verify the solution works for your specific use case._`;

//         // Post the comment
//         await context.octokit.issues.createComment(
//           context.issue({ body: commentBody })
//         );
        
//       } catch (err: any) {
//         console.error(`‚ùå Failed to handle issue #${issueNumber ?? "(unknown)"}:`, err?.message);
//         console.error(err?.stack);
//       }
//   });
// };

import { Probot, Context } from "probot";
import * as dotenv from "dotenv";
import { createOpenAI } from "@ai-sdk/openai";
import { generateText } from "ai";
import {
  ProvideAIAnnotationsToolSchema,
  ProvideLinksToolSchema
} from "./schemas.js";
import type { Message } from "ai";
import type { Messages, UserProperties } from '@inkeep/inkeep-analytics/models/components';
import { logToInkeepAnalytics } from './logToInkeepAnalytics';

dotenv.config();

export default (app: Probot) => {
  const inkeepModel = 'inkeep-qa-expert';
  const openai = createOpenAI({
    apiKey: process.env.INKEEP_API_KEY,
    baseURL: 'https://api.inkeep.com/v1'
  });

  const systemPrompt = `
You are a helpful AI assistant responding to GitHub issues. Your goal is to provide accurate, helpful answers based on available documentation and knowledge sources.

- Be direct and concise in your responses
- Focus on providing actionable solutions
- If you're not confident about an answer, indicate your uncertainty
- Use a natural, helpful tone without being overly formal
- Avoid phrases like "According to the documentation" - just state facts directly
`;

  app.on(["issues.opened", "issues.reopened"], async (context: Context) => {
    // Make number available in catch scope
    let issueNumber: number | undefined = undefined;
    try {
      if (!('issue' in context.payload)) {
        console.error("‚ùå Event payload does not contain an 'issue' property.");
        return;
      }
      const { title, body, number, user } = context.payload.issue;
      issueNumber = number;
      const safeTitle = title ?? "";
      const safeBody = body ?? "";
      const fullQuestion = `${safeTitle}\n\n${safeBody}`;

      console.log(`üìù Issue #${number} received: "${safeTitle}"`);

      // Initialize analytics data
      const messagesToLogToAnalytics: Messages[] = [];
      const issueProperties = {
        issueId: number,
        issueTitle: safeTitle,
        repository: context.payload.repository?.full_name,
        issueUrl: context.payload.issue.html_url,
      };
      
      const userProperties: UserProperties = {
        userId: user?.id?.toString() || 'unknown',
        additionalProperties: {
          username: user?.login,
          email: user?.email || null,
          githubUrl: user?.html_url,
          userType: user?.type,
        },
      };

      // Log the user's question
      messagesToLogToAnalytics.push({
        content: fullQuestion,
        role: 'user',
      });

      // Prepare messages with system prompt
      const messages: Message[] = [
        { id: "system-1", role: "system", content: systemPrompt },
        { id: "user-1", role: "user", content: fullQuestion }
      ];

      // Call Inkeep model with AI tools
      const { text, toolCalls } = await generateText({
        model: openai(inkeepModel),
        messages,
        tools: {
          provideAIAnnotations: { 
            parameters: ProvideAIAnnotationsToolSchema 
          },
          provideLinks: { 
            parameters: ProvideLinksToolSchema 
          }
        },
        toolChoice: 'auto'
      });

      // Extract AI annotations (confidence level)
      const aiAnnotations = toolCalls.find(tc => tc.toolName === 'provideAIAnnotations')
        ?.args.aiAnnotations;
      
      const confidence = aiAnnotations?.answerConfidence ?? 'unknown';
      const explanation = (aiAnnotations as any)?.explanation ?? '';

      console.log(`üéØ Issue #${number} confidence level: ${confidence}`);

      // Only respond if confidence is high enough (matching Zendesk logic)
      const shouldRespond = confidence === 'very_confident';
      
      if (!shouldRespond) {
        console.log(`üîá Skipping issue #${number}: confidence level '${confidence}' below threshold`);
        
        // Log the low confidence response to analytics
        const confidenceNote = `AI Agent had ${confidence} confidence level in its answer: ${text}`;
        messagesToLogToAnalytics.push({
          content: confidenceNote,
          role: 'assistant',
        });

        // Log to Inkeep Analytics
        await logToInkeepAnalytics({
          messagesToLogToAnalytics,
          properties: {
            ...issueProperties,
            responseGenerated: false,
            confidenceLevel: confidence,
            explanation,
          },
          userProperties,
        });
        
        // Optionally add a subtle note for somewhat_confident cases
        if (confidence === 'somewhat_confident') {
          console.log(`üí≠ Issue #${number} was somewhat confident but below response threshold`);
        }
        return;
      }

      // Build the response comment
      let commentBody = `ü§ñ Here's a suggested solution:\n\n${text}`;
      
      // Add confidence indicator
      if (confidence === 'very_confident') {
        commentBody += `\n\n‚úÖ _High confidence response_`;
      }
      
      // Add explanation if provided
      if (explanation) {
        commentBody += `\n\nüí° _${explanation}_`;
      }
      
      commentBody += `\n\n---\n_This response was generated by an AI assistant. Please verify the solution works for your specific use case._`;

      // Post the comment
      await context.octokit.issues.createComment(
        context.issue({ body: commentBody })
      );

      console.log(`‚úÖ Responded to issue #${number} with confidence '${confidence}'`);

      // Log the successful response to analytics
      messagesToLogToAnalytics.push({
        content: text, // Log the original AI response, not the formatted comment
        role: 'assistant',
      });

      // Log to Inkeep Analytics
      await logToInkeepAnalytics({
        messagesToLogToAnalytics,
        properties: {
          ...issueProperties,
          responseGenerated: true,
          confidenceLevel: confidence,
          explanation,
          commentPosted: true,
        },
        userProperties,
      });
      
    } catch (err: any) {
      console.error(`‚ùå Failed to handle issue #${issueNumber ?? "(unknown)"}:`, err?.message);
      console.error(err?.stack);
      
      // Log error to analytics if we have the basic data
      if (issueNumber) {
        try {
          await logToInkeepAnalytics({
            messagesToLogToAnalytics: [{
              content: `Error processing issue: ${err?.message}`,
              role: 'assistant',
            }],
            properties: {
              issueId: issueNumber,
              error: err?.message,
              responseGenerated: false,
            },
            userProperties: {
              userId: 'unknown',
            },
          });
        } catch (analyticsErr) {
          console.error('Failed to log error to analytics:', analyticsErr);
        }
      }
    }
  });
};